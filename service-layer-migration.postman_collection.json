{
  "info": {
    "name": "Service Layer Migration Plan Query",
    "description": "Collection for querying Project Assistant with Service Layer Migration Plan",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Query - Service Layer Migration Plan",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Authorization",
            "value": "Bearer proj_92-lcvVNUs61dK_cT5UBS5KksgdxzG1tzN_MTokwkQ4",
            "type": "text"
          },
          {
            "key": "Content-Type",
            "value": "application/json",
            "type": "text"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"query\": \"---\\nname: Service Layer Migration with Transactions\\noverview: Migrate all 32 NestJS services to Spring Boot service layer with @Transactional support, role-based authorization, audit logging, and multi-tenancy patterns. Services will use Spring Data JPA repositories and PostgreSQL transactions.\\ntodos: []\\n---\\n\\n# Service Layer Migration Plan\\n\\n## Overview\\n\\nMigrate all 32 NestJS services (`*.service.ts`) to Spring Boot service layer (`*Service.java`) with comprehensive transactional support using Spring's `@Transactional` annotation. Each service will follow Spring Boot patterns while maintaining the business logic from NestJS.\\n\\n## Current State\\n\\n- **NestJS**: 32 service files in `src/features/*/`\\n- **Spring Boot**: Controllers, entities, repositories, DTOs, and mappers exist; **no service layer yet**\\n- **Transaction Pattern**: NestJS uses MongoDB sessions (`ClientSession`) with manual transaction management\\n- **Target**: Spring Boot services with `@Transactional` for declarative transaction management\\n\\n## Service Inventory\\n\\nAll services to migrate (32 total):\\n\\n1. `auth/auth.service.ts` → `AuthService.java`\\n2. `bulk/bulk.service.ts` → `BulkService.java`\\n3. `companies/companies.service.ts` → `CompaniesService.java`\\n4. `companies/companies-import.service.ts` → `CompaniesImportService.java`\\n5. `company-locations/company-locations.service.ts` → `CompanyLocationsService.java`\\n6. `compliance/compliance.service.ts` → `ComplianceService.java`\\n7. `contact-inquiries/contact-inquiries.service.ts` → `ContactInquiriesService.java`\\n8. `contacts/contacts.service.ts` → `ContactsService.java`\\n9. `cost-codes/cost-codes.service.ts` → `CostCodesService.java`\\n10. `crm-context/crm-context.service.ts` → `CrmContextService.java`\\n11. `dev-seed/dev-seed.service.ts` → `DevSeedService.java`\\n12. `email/email.service.ts` → `EmailService.java`\\n13. `email-templates/email-templates.service.ts` → `EmailTemplatesService.java`\\n14. `estimates/estimates.service.ts` → `EstimatesService.java`\\n15. `graph-edges/graph-edges.service.ts` → `GraphEdgesService.java`\\n16. `ingestion/ingestion-contacts.service.ts` → `IngestionContactsService.java`\\n17. `invites/invites.service.ts` → `InvitesService.java`\\n18. `legal/legal.service.ts` → `LegalService.java`\\n19. `migrations/migrations.service.ts` → `MigrationsService.java`\\n20. `notifications/notifications.service.ts` → `NotificationsService.java`\\n21. `offices/offices.service.ts` → `OfficesService.java`\\n22. `org-taxonomy/org-taxonomy.service.ts` → `OrgTaxonomyService.java`\\n23. `organizations/organizations.service.ts` → `OrganizationsService.java`\\n24. `people/people-import.service.ts` → `PeopleImportService.java`\\n25. `persons/persons.service.ts` → `PersonsService.java`\\n26. `projects/projects.service.ts` → `ProjectsService.java`\\n27. `rbac/rbac.service.ts` → `RbacService.java`\\n28. `seats/seats.service.ts` → `SeatsService.java`\\n29. `sessions/sessions.service.ts` → `SessionsService.java`\\n30. `sms/sms.service.ts` → `SmsService.java`\\n31. `users/users.service.ts` → `UsersService.java`\\n32. `waitlist/waitlist.service.ts` → `WaitlistService.java`\\n\\n## Common Infrastructure Components\\n\\n### 1. Base Service Utilities (`service/common/`)\\n\\nCreate shared service utilities:\\n\\n- **`ActorContext.java`**: Java equivalent of NestJS `ActorContext` type\\n  ```java\\n  @Getter\\n  @Setter\\n  @NoArgsConstructor\\n  @AllArgsConstructor\\n  public class ActorContext {\\n      private String userId;\\n      private String orgId;\\n      private Role role;\\n  }\\n  ```\\n\\n- **`ServiceAuthorizationHelper.java`**: Common authorization methods\\n  - `ensureRole(ActorContext actor, Role[] allowed)`\\n  - `ensureOrgScope(String orgId, ActorContext actor)`\\n  - `canViewArchived(ActorContext actor)`\\n  - `ensureNotOnLegalHold(Object entity, String action)`\\n\\n- **`ServiceValidationHelper.java`**: Validation utilities\\n  - `validateOrg(String orgId)`\\n  - `normalizeEmail(String email)`\\n  - `normalizePhone(String phone)`\\n  - `parseOptionalDate(String value)`\\n\\n### 2. Transaction Configuration\\n\\n- **`@Transactional`** on all service methods that modify data\\n- **`@Transactional(readOnly = true)`** on read-only methods\\n- **`@Transactional(rollbackFor = Exception.class)`** for operations that should rollback on any exception\\n- **`@Transactional(propagation = Propagation.REQUIRES_NEW)`** for operations that need separate transactions (e.g., audit logging)\\n\\n### 3. Audit Logging Service\\n\\nCreate `AuditLogService.java` that wraps Spring's audit capabilities:\\n\\n```java\\n@Service\\npublic class AuditLogService {\\n    private final AuditRepository auditRepository;\\n    \\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\\n    public void log(String eventType, String orgId, String userId, String entity, String entityId, Map<String, Object> metadata) {\\n        // Log to audit table\\n    }\\n}\\n```\\n\\n## Architecture: Controller-Service Separation\\n\\n**Key Principle**: Controllers handle DTO ↔ Entity mapping, Services work only with Entities.\\n\\n### Controller Responsibilities\\n\\n- Receive DTOs from HTTP requests\\n- Map DTOs to Entities using mappers\\n- Call service methods with Entities\\n- Map returned Entities to DTOs\\n- Return DTOs in HTTP responses\\n\\n### Service Responsibilities\\n\\n- Work exclusively with Entity objects\\n- Perform business logic and validation\\n- Interact with repositories\\n- Handle transactions\\n- Return Entity objects\\n\\n## Migration Pattern\\n\\n### Controller Example\\n\\n```java\\n@RestController\\n@RequiredArgsConstructor\\n@RequestMapping(\\\"/api/projects\\\")\\npublic class ProjectController {\\n    private final ProjectsService projectsService;\\n    private final ProjectMapper projectMapper;\\n    \\n    @PostMapping\\n    public ResponseEntity<ProjectDto> create(\\n            @RequestBody @Valid CreateProjectDto dto,\\n            @AuthenticationPrincipal ActorContext actor) {\\n        // Map DTO to Entity\\n        Project project = projectMapper.toEntity(dto);\\n        \\n        // Call service with Entity\\n        Project createdProject = projectsService.create(project, actor);\\n        \\n        // Map Entity to DTO for response\\n        return ResponseEntity.ok(projectMapper.toDto(createdProject));\\n    }\\n    \\n    @GetMapping\\n    public ResponseEntity<List<ProjectDto>> list(\\n            @RequestParam(required = false) String orgId,\\n            @RequestParam(defaultValue = \\\"false\\\") boolean includeArchived,\\n            @AuthenticationPrincipal ActorContext actor) {\\n        // Service returns Entities\\n        List<Project> projects = projectsService.list(actor, orgId, includeArchived);\\n        \\n        // Map Entities to DTOs\\n        List<ProjectDto> dtos = projects.stream()\\n            .map(projectMapper::toDto)\\n            .toList();\\n        \\n        return ResponseEntity.ok(dtos);\\n    }\\n}\\n```\\n\\n### Service Example\\n\\n```java\\n@Service\\n@RequiredArgsConstructor\\n@Slf4j\\npublic class ProjectsService {\\n    private final ProjectRepository projectRepository;\\n    private final OrganizationRepository organizationRepository;\\n    private final OfficeRepository officeRepository;\\n    private final CostCodeRepository costCodeRepository;\\n    private final PersonsService personsService;\\n    private final SeatsService seatsService;\\n    private final AuditLogService auditLogService;\\n    private final ServiceAuthorizationHelper authHelper;\\n    \\n    @Transactional\\n    public Project create(Project project, ActorContext actor) {\\n        authHelper.ensureRole(actor, Role.ADMIN, Role.MANAGER, Role.ORG_OWNER);\\n        String orgId = authHelper.resolveOrgId(project.getOrgId(), actor);\\n        authHelper.validateOrg(orgId);\\n        \\n        // Set orgId on entity\\n        project.setOrgId(orgId);\\n        \\n        // Business logic validation...\\n        validateProjectName(project.getName(), orgId);\\n        \\n        // Save entity\\n        Project savedProject = projectRepository.save(project);\\n        \\n        // Audit logging\\n        auditLogService.log(\\\"project.created\\\", orgId, actor.getUserId(), \\n            \\\"Project\\\", savedProject.getId().toString(), metadata);\\n        \\n        // Return Entity (not DTO)\\n        return savedProject;\\n    }\\n    \\n    @Transactional(readOnly = true)\\n    public List<Project> list(ActorContext actor, String orgId, boolean includeArchived) {\\n        authHelper.ensureRole(actor, Role.ADMIN, Role.MANAGER, Role.ORG_OWNER, Role.PM, Role.VIEWER);\\n        String resolvedOrgId = authHelper.resolveOrgId(orgId, actor);\\n        \\n        // Return Entities (not DTOs)\\n        if (includeArchived) {\\n            return projectRepository.findByOrgId(resolvedOrgId);\\n        } else {\\n            return projectRepository.findByOrgIdAndArchivedAtIsNull(resolvedOrgId);\\n        }\\n    }\\n    \\n    @Transactional\\n    public Project update(Long id, Project projectUpdates, ActorContext actor) {\\n        Project existingProject = projectRepository.findById(id)\\n            .orElseThrow(() -> new ResourceNotFoundException(\\\"Project not found\\\"));\\n        \\n        authHelper.ensureOrgScope(existingProject.getOrgId(), actor);\\n        authHelper.validateOrg(existingProject.getOrgId());\\n        \\n        // Update entity fields\\n        if (projectUpdates.getName() != null) {\\n            existingProject.setName(projectUpdates.getName());\\n        }\\n        // ... other field updates\\n        \\n        Project updatedProject = projectRepository.save(existingProject);\\n        \\n        auditLogService.log(\\\"project.updated\\\", updatedProject.getOrgId(), \\n            actor.getUserId(), \\\"Project\\\", updatedProject.getId().toString(), metadata);\\n        \\n        // Return Entity (not DTO)\\n        return updatedProject;\\n    }\\n}\\n```\\n\\n## Transaction Strategy\\n\\n### NestJS → Spring Boot Transaction Mapping\\n\\n| NestJS Pattern | Spring Boot Equivalent |\\n|----------------|------------------------|\\n| `session.startTransaction()` | `@Transactional` (method-level) |\\n| `session.commitTransaction()` | Automatic commit on method success |\\n| `session.abortTransaction()` | Automatic rollback on exception |\\n| `session.endSession()` | Automatic session cleanup |\\n| `{ session }` parameter | Transaction context automatically propagated |\\n\\n### Transaction Propagation\\n\\n- **Default**: `REQUIRED` - Join existing transaction or create new\\n- **Audit Logging**: `REQUIRES_NEW` - Always create new transaction (don't rollback audit on main failure)\\n- **Read Operations**: `readOnly = true` - Optimize for read-only queries\\n\\n### Example: Complex Transaction (InvitesService.accept)\\n\\n**NestJS**:\\n\\n```typescript\\nconst session = await this.inviteModel.db.startSession();\\ntry {\\n  session.startTransaction();\\n  // ... operations with session\\n  await session.commitTransaction();\\n} catch (err) {\\n  await session.abortTransaction();\\n  throw err;\\n} finally {\\n  session.endSession();\\n}\\n```\\n\\n**Spring Boot Service**:\\n\\n```java\\n@Transactional(rollbackFor = Exception.class)\\npublic Invite accept(Invite invite, ActorContext actor) {\\n    // Service works with Entity (Invite), not DTO\\n    // All operations automatically in transaction\\n    // Rollback on any exception\\n    // Returns Entity, not DTO\\n}\\n```\\n\\n**Spring Boot Controller**:\\n\\n```java\\n@PostMapping(\\\"/accept\\\")\\npublic ResponseEntity<AcceptInviteResponseDto> accept(\\n        @RequestBody @Valid AcceptInviteDto dto) {\\n    // Map DTO to Entity\\n    Invite invite = inviteMapper.toEntity(dto);\\n    \\n    // Call service with Entity\\n    Invite acceptedInvite = invitesService.accept(invite, actor);\\n    \\n    // Map Entity to DTO\\n    return ResponseEntity.ok(inviteMapper.toDto(acceptedInvite));\\n}\\n```\\n\\n## Service Dependencies\\n\\nServices depend on:\\n\\n- **Repositories**: Spring Data JPA repositories (already exist) - for database operations\\n- **Other Services**: Injected via constructor (Spring dependency injection) - for cross-service calls\\n- **AuditLogService**: For audit logging\\n- **Authorization Helpers**: For role/org checks\\n\\n**Services do NOT depend on:**\\n\\n- **Mappers**: Controllers handle DTO ↔ Entity mapping, services work only with Entities\\n- **DTOs**: Services receive and return Entity objects only\\n\\n## Implementation Order\\n\\n### Phase 1: Infrastructure (Foundation)\\n\\n1. Create `ActorContext` class\\n2. Create `ServiceAuthorizationHelper` with common authorization methods\\n3. Create `ServiceValidationHelper` with validation utilities\\n4. Create `AuditLogService` wrapper\\n5. Create base service package structure\\n\\n### Phase 2: Core Services (High Priority)\\n\\n6. `OrganizationsService` - Foundation for multi-tenancy\\n7. `UsersService` - Authentication foundation\\n8. `AuthService` - Authentication logic\\n9. `PersonsService` - Core entity management\\n10. `ProjectsService` - Complex business logic example\\n\\n### Phase 3: Entity Management Services\\n\\n11. `CompaniesService` + `CompaniesImportService`\\n12. `CompanyLocationsService`\\n13. `OfficesService`\\n14. `ContactsService`\\n15. `CostCodesService`\\n\\n### Phase 4: Business Logic Services\\n\\n16. `EstimatesService`\\n17. `GraphEdgesService`\\n18. `InvitesService` (complex transaction example)\\n19. `SeatsService`\\n20. `RbacService`\\n\\n### Phase 5: Supporting Services\\n\\n21. `EmailService` + `EmailTemplatesService`\\n22. `NotificationsService`\\n23. `SessionsService`\\n24. `SmsService`\\n25. `LegalService`\\n26. `ComplianceService`\\n\\n### Phase 6: Integration Services\\n\\n27. `BulkService` - Complex import/export logic\\n28. `IngestionContactsService`\\n29. `ContactInquiriesService`\\n30. `CrmContextService`\\n31. `MigrationsService`\\n32. `WaitlistService`\\n33. `DevSeedService` - Development only\\n\\n## Key Files to Create\\n\\n### Infrastructure\\n\\n- `spring-boot-api/src/main/java/com/mytegroup/api/service/common/ActorContext.java`\\n- `spring-boot-api/src/main/java/com/mytegroup/api/service/common/ServiceAuthorizationHelper.java`\\n- `spring-boot-api/src/main/java/com/mytegroup/api/service/common/ServiceValidationHelper.java`\\n- `spring-boot-api/src/main/java/com/mytegroup/api/service/common/AuditLogService.java`\\n\\n### Service Package Structure\\n\\n```\\nspring-boot-api/src/main/java/com/mytegroup/api/service/\\n├── common/           # Shared utilities\\n├── auth/             # AuthService\\n├── bulk/             # BulkService\\n├── companies/        # CompaniesService, CompaniesImportService\\n├── companylocations/ # CompanyLocationsService\\n├── compliance/       # ComplianceService\\n├── contactinquiries/ # ContactInquiriesService\\n├── contacts/         # ContactsService\\n├── costcodes/        # CostCodesService\\n├── crmcontext/       # CrmContextService\\n├── email/            # EmailService\\n├── emailtemplates/   # EmailTemplatesService\\n├── estimates/        # EstimatesService\\n├── graphedges/       # GraphEdgesService\\n├── ingestion/        # IngestionContactsService\\n├── invites/          # InvitesService\\n├── legal/            # LegalService\\n├── migrations/       # MigrationsService\\n├── notifications/    # NotificationsService\\n├── offices/          # OfficesService\\n├── orgtaxonomy/      # OrgTaxonomyService\\n├── organizations/    # OrganizationsService\\n├── people/           # PeopleImportService\\n├── persons/          # PersonsService\\n├── projects/         # ProjectsService\\n├── rbac/             # RbacService\\n├── seats/            # SeatsService\\n├── sessions/         # SessionsService\\n├── sms/              # SmsService\\n├── users/            # UsersService\\n└── waitlist/         # WaitlistService\\n```\\n\\n## Transaction Best Practices\\n\\n1. **Read Operations**: Always use `@Transactional(readOnly = true)`\\n2. **Write Operations**: Use `@Transactional` (default REQUIRED propagation)\\n3. **Complex Operations**: Use `@Transactional(rollbackFor = Exception.class)` for explicit rollback\\n4. **Audit Logging**: Use `REQUIRES_NEW` propagation to ensure audit records persist even if main transaction fails\\n5. **Service-to-Service Calls**: Transactions propagate automatically within same thread\\n6. **Exception Handling**: Let Spring handle transaction rollback automatically\\n\\n## Testing Strategy\\n\\n- Unit tests: Mock repositories and dependencies\\n- Integration tests: Use `@Transactional` on test methods to rollback after test\\n- Transaction tests: Verify rollback behavior on exceptions\\n- Authorization tests: Verify role/org checks work correctly\\n\\n## Notes\\n\\n- **Separation of Concerns**: Controllers handle DTO ↔ Entity mapping, Services work only with Entities\\n- **Mappers**: Located in `mapper/` package, used only by Controllers, not Services\\n- **Service Methods**: All service methods receive and return Entity objects (not DTOs)\\n- **Controller Methods**: All controller methods receive and return DTOs, perform mapping before/after service calls\\n- All services use constructor injection (Lombok `@RequiredArgsConstructor`)\\n- All services use `@Slf4j` for logging\\n- Transaction boundaries are method-level (declarative transactions)\\n- No manual transaction management needed (Spring handles it)\\n- PostgreSQL transactions are ACID compliant (vs MongoDB's eventual consistency)\\n- Multi-tenancy handled via organization scoping in queries\\n\",\n  \"additional_context\": []\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "https://api.myte.dev/api/project-assistant/query",
          "protocol": "https",
          "host": [
            "api",
            "myte",
            "dev"
          ],
          "path": [
            "api",
            "project-assistant",
            "query"
          ]
        }
      },
      "response": []
    }
  ]
}

